---
title: "Php, caca et programmation orientée objet (POO)"
date: "2023-12-14"
slug: "php-poo"
hero_image: "./elephant.jpg"
hero_image_alt: "L'elephant de php"
hero_image_credit_text: "DeepAi"
hero_image_credit_link: ""
published: true
---

Aujourd'hui, j'aimerai aborder la programmation sur un ton plus léger. Je voudrais vous raconter comment j'ai découvert la programmation
orientée objet, comment je l'ai comprise et comment tout cela m'a amené à concevoir un projet assez... original !


## Au commencement

J'ai commencé l'apprentissage de la programmation avec java fin 2012. J'ai d'abord appris la programmation impérative et j'aprenanit avec
pas mal d'aisance. Puis j'ai migré sur la programmation orienté objet et là, cela s'est beaucoup moins bien passé. Avec le recul je pense
que cela est dû à plusieurs facteurs. D'abord les travaux à réaliser étaient moins créatif car ils s'agissait beaucoup d'écriture
de setteurs de getteurs : du code bien redondant à coup de copier coller. De plus, j'ai été confronté à ce que j'appelle le problème du
pourquoi vs comment. C'est à dire que les cours étaient bien plus orienté sur ce que la poo apportait sans pour autant justifier ces choix
de design. je savais comment ça marchait, mais pas pourquoi ça marchait comme ça.

Cela durera jusqu'en 2015 où, pendant que je suivais des moocs de programmation, je tombait sur un langage assez exotique vis à vis de ce
que je connaissais jusque là : Pharo. Contrairement à Java où Php, Pharo est un langage de programmation objet pur et les instructions impératives
de ces deux langages, comme les conditions et les boucles, sont alors des appels de méthode. Autre changement assez conséquent : les classes
elle-même sont des objets.

Malgré sa syntaxe assez particulière et le fait que je n'ai toujours pas produit de code pharo à ce jour, ça a été une révélation qui m'a grandement
aidé à comprendre l'orienté objet.

Pour un peu de culture, voici un exmeple de code pharo, tiré du livre *pharo par l'exemple*.
```smalltalk
initialize
  | sampleCell width height n |
  super initialize.
  n := self cellsPerSide.
  sampleCell := LOCell new.
  width := sampleCell width.
  height := sampleCell height.
  self bounds: (5@5 extent: ((width*n) @(height*n)) + (2 * self borderWidth)).
  cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]
```


## Et Php dans tout ça ?

C'est peu de temps après que je me suis penché sur le langage Php, et l'onboarding n'a pas été des plus fameux ! Je pourrais critiquer pas mal de
points mais je me concentrerais sur un seul, ce n'était pas l'orienté objet que j'avais appris à aimer. Cela a été la source de pas mal de
frustration, au point qu'il m'est venu l'envie d'y palier en lançant un projet assez loufoque : recréer l'OOP de PHP. N'étant pas sûr de la
possibilité d'une telle démarche, je décide de ne renomer *Php's Object Oriented Project*, ou POOP pour les intimes.

Les premier essais ne sont pas fameux et font usage de code assez discutable. C'est assez logique, si je veux retrouver cette POO que j'aime
il me faut refaire la classes, l'héritage, l'accès à self et super... tout ça n'est pas chose aisée. Pour vous montrer un exmeple, voici un
bout de code du premier jet avec une fonction *self* qui renvoi l'objet qui l'appelle :

```php
function _self(){
    $objet = debug_backtrace();
    return $objet[2]["object"];
}
```

Mon code complet est disponible https://github.com/HellperKK/Poop/blob/087e249d783ff5058f7aafd87a802bd8855500dc/Lib.php, et on peut trouver
d'autres excentircités de code. Pour cette raison, le projet sera mis de côté, faute d'être une solution pratique à utiliser. Jusqu'au
jour où, j'ai repris le projet.


## IO, javascript et prototypage

Si j'aime l'idée que les classes soient des objets, je dois avouer que cela implique pas mal de complexité. En Pharo chaque classe crée
ajoute la création d'une metaclasse dont la classe est instance, avec un arbre d'héritage de metaclasses en parallèle de celuid es classes.
Il y a aussi ruby, qui propose une alternative moins lourde mais tout de même tordue à mon sens. Toute classe est instance de la classe *Class*,
qui est instance d'elle-même, et hérite indirectement de la class *Object* qui du coup est aussi instance de la classe *Class*. De quoi donner le
tourni...

Au bout d'un moment et à force de réfléchir m'est venur une question : si je veux manipuler des objets qui sont instances de classes elle-même objet,
ne serait-être pas préférable de mettre les deux concept de classes et d'instances au même niveau pour ne manipuler que des objets ? c'est ainsi que
je me suis intéressé au concept de prototype.

En m'inspirant des langages de programmtion IO et javascript (avec un peu de python), j'ai trouvé moyen de faire une bibliothèque Php permetant de
faire de la Poo sans avoir à écrire de classe. Une seule classe est nécessaire et est déjà fournie. Le fonctionnement est le suivant :
```php
<?php

// On crée une instance en clonant l'objet statique object de la bibliothèque
include "src/lib.php";
$Range = Instance::object()->clone();

// On définit les propriété de notre objet range
$Range->max = 10;
$Range->min = 0;

// Pour la méthode, comme en python le premier paramètre est l'instance et est obligatoire
// Il est passé implicitement à la méthode, qu'on utilise comme ceci => $Range->include(42)
$Range->include = function($self, $value)
{
  return ($self->max > $value) && ($self->min <= $value);
};

// On peut créer une méthode make pour produire des ranges à volonté
$Range->make = function($self, $min, $max)
{
  $new = $self->clone();
  $new->min = $min;
  $new->max = $max;
  return $new;
};

// A l'usage
$newRange = $Range->make(0, 10);
$newRange->include(42);
```


## Conclusion

En conclusion je dirais que j'ai beaucoup exploré le concept d'oreinté objet durant cette aventure. C'est un paradigme léger
qui permet de nombreuses interprétations, ce qui peut lui être reproché mais j'y vois aussi une force. Au final je n'utilise pas
Poop dans mon code Php et je suis assez dubitatif quant à ses perofrmances, mais je suis content de ce que j'ai pu apprendr en chemin.


### Epilogue et limonade

En plus de cela, j'ai fini par ajouter cette forme d'orienté objet dans un langage de programmation que je développe, que j'ai baptisé
limonade. Son nom viens de la grande lignée des langages générant du javascript (coffescript, caffeine, earl grey...). Bien qu'il me reste
encore beaucoup de travail, limonade a pour but d'être un langage de programmation statiquement typé, oreinté objet et fonctionnel, mais
très peu impératif, qui transpilera en js. Ce qui j'espère lui permettra de sortir du lot :)

Merci d'avoir lu et à une prochaine !